# 주문 개선하기: 시퀀스 테이블 페이드아웃

2024년 2분기부터 시작한 주문 개선하기 중 첫 번째로 작업했던 시퀀스 테이블 페이드아웃에 대한 이야기를 적어보도록 하겠습니다.

지난 1분기에 물류와 커머스간 의존성을 격리한 다음으로는 커머스에 주문 트래픽이 몰릴때 서비스가 안정적으로 운영될 수 있도록 주문 프로세스를 개선해야했다.

## 이전 글
- [1.대량 상품 출고 데이터 처리](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/1.%EB%8C%80%EB%9F%89%20%EC%83%81%ED%92%88%20%EC%B6%9C%EA%B3%A0%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B2%98%EB%A6%AC.md)
- [2.서비스간 의존성 격리: 트랜잭셔널 아웃박스 패턴](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2.%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B0%84%20%EC%9D%98%EC%A1%B4%EC%84%B1%20%EA%B2%A9%EB%A6%AC%3A%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90%20%EC%95%84%EC%9B%83%EB%B0%95%EC%8A%A4%20%ED%8C%A8%ED%84%B4.md)

## 문제 상황
일반적으로 고객이 상품을 고른 뒤 주문부터 결제하기까지 간략하게 아래와 같은 프로세스를 거치게 된다.
- 고객이 상품을 장바구니에 담는다.
  - 장바구니 상품 데이터 n개가 생성된다.
- 장바구니에 담긴 상품을 주문한다.
  - 주문서가 생성되고 주문서에 있는 주문 아이템 데이터 n개가 생성된다.  
- 주문을 결제한다.
  - 결제가 이루어지는동안 결제 이력 데이터가 쌓인다.(결제 요청 ~ 성공)

당시 서비스에서는 데이터의 식별키를 생성하는데 시퀀스 테이블이 사용되고 있었다.  
시퀀스 테이블은 key value 두개의 컬럼을 가진 구조로 이루어져있다.  
### SEQUENCE_TABLE

| key | value |
|-----|-------|
| 장바구니_시퀀스   | 54324959   |
| 주문_시퀀스   | 13453253   |
| 결제_시퀀스   | 26906506   |


시퀀스 테이블의 사용방법은 간단하다.   
시퀀스의 키를 파라미터로 받는 함수를 호출하면 키에 해당하는 시퀀스의 값을 조회 한 뒤 현재 값에 +1을 해서 테이블을 업데이트하고 업데이트 된 값을 반환한다.  
```
getSequence(keyParam) {
  select 현재_시퀀스 from 시퀀스테이블 where key = keyParam;
  다음_시퀀스 = 현재_시퀀스 + 1;

  update 시퀀스테이블 SET value = 다음_시퀀스 where key = keyParam;
  return 다음_시퀀스;
}

seqeunce = getSeqeuence("주문_시퀀스");
```

시퀀스 테이블은 트래픽이 높지 않다면 아무 문제 없을 수 있다.  
하지만 조금만 트래픽이 많아져도 문제가 될 수 있다.  

## 문제 발생
이벤트가 있을 때는 스파이크 트래픽이 발생하는데 짧은 시간동안 고객이 한꺼번에 많이 유입되어서 상품을 담고 주문과 결제를 진행한다.  
상품이 담기고 주문이 생성되고 결제가 이루어지는 액션이 증가함에 따라 시퀀스 테이블의 업데이트 횟수 역시 증가하게 된다.   
그러다보면 시퀀스 테이블은 Lock이 걸릴 수 밖에 없고, 이로 인해 대기열이 쌓이면서 처리 시간이 증가하고 결국 타임 아웃으로 주문 요청은 실패하게 된다.

<p align="center">
  <img src="https://github.com/ejoongseok/blog/assets/99948743/97f463ea-2885-4805-8fa6-d654d568b1b8"></img>
</p>

그렇기 때문에 이벤트 같은 상황에서도 주문이 안정적으로 이루어지기 위해서는 시퀀스를 개선해야했다.  

다행히 이미 팀에서 2023년 3분기 즈음에 시퀀스 테이블을 페이드아웃 할 계획으로 인메모리 시퀀스로 구성된 티켓 서버를 구축해서 일부 사용중인 상태였다.  

## 개선 방법
아래의 순서로 약 1달간 작업하고 모니터링을 진행하면서 주문에서 시퀀스 테이블을 페이드아웃 했다.  
1. 주문에서 사용되는 시퀀스가 다른 서비스에서도 사용되는지를 전부 찾고 해당 시퀀스가 1년간 얼마나 증가하는지 집계한다.  
2. 시퀀스가 3년동안 증가해야 도달할 수 있을정도의 값으로 인메모리 시퀀스에 적재한다.  
3. 로직에서 시퀀스를 생성할때 바로 생성하지 않고 파사드를 통하도록 변경한다.  
4. 파사드에 피처플래그를 추가하고 시퀀스를 DB에서 생성하는 코드와 티켓서버에서 생성하는 코드로 분기한다.  
5. 티켓서버를 통해 시퀀스를 가져오도록 플래그를 변경한 뒤 DB의 시퀀스가 증가하지 않는지 모니터링을 한다.  
6. 다음 페이드아웃 대상 시퀀스에 대해서 1~5 반복  

### 고려해야하는 부분
단순한 작업이었지만 티켓서버와 DB의 시퀀스가 동시에 사용되면 안되는 문제였기 때문에 꼼꼼히 체크하고 모니터링도 길게하면서 천천히 진행했다.  

티켓서버와 DB의 시퀀스가 동시에 사용되면 안되는 이유는 ID로 정렬할때 순서가 맞지 않기 때문이었다.   

티켓서버의 시퀀스와 시퀀스 테이블의 시퀀스 두개가 다 사용되는 상황에서 시퀀스로 내림차순 정렬을 하면,  
시퀀스 테이블으로 생성된 데이터가 더 최신 데이터여도 밑에 보이게 되는 문제가 발생한다.

#### XXX_TABLE

| SEQ | CREATED_AT |
|-----|-------|
| 50000 | 2023-06-29 14:00:00 |
| ... | ... |
| 15000 | 2023-06-29 16:00:00 (최신 데이터인데 시퀀스가 더 낮음)|

``` SQL
 SELECT SEQ
 FROM XXX_TABLE
 ORDER BY SEQ DESC
 LIMIT 5
```

결과적으로 하나씩 천천히 페이드 아웃 하면서 긴 시간 모니터링을 거친 끝에,   
주문에서 사용되는 모든 시퀀스를 티켓서버를 통해 가져오도록 개선할 수 있었다. 

## 성과
주문에서 사용 되는 시퀀스를 인메모리로 전환한 뒤 시퀀스 테이블에 의해 발생하는 성능 저하를 해소 할 수 있게 되었고,    
주문이 몰리는 상황에서 보다 안정적인 서비스를 제공 할 수 있게 되었다.

## 다음 과제
시퀀스 생성을 티켓 서버로 전환하면서 주문에 대한 안정성은 많이 높일 수 있었다.  
하지만 잦은 업데이트는 시퀀스 테이블에서만 발생하는게 아니었다.   

주문이 이루어지면 주문에 담긴 각 상품의 재고가 변경되어야 하는데, 주문이 많아지면 상품 재고 업데이트 역시 많이 발생하는 구조이기 때문에 개선이 필요했다.  

이 내용은 다음 글에서 작성해보도록 하겠습니다.  

감사합니다.

## 다음 글
- [4.주문 개선하기: 재고 업데이트 안정화](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/4.%EC%A3%BC%EB%AC%B8%20%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0%3A%20%EC%9E%AC%EA%B3%A0%20%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%20%EC%95%88%EC%A0%95%ED%99%94.md)
