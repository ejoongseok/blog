# 레거시 시스템 세션 의존성 제거하기

2024년 4분기에 오랫동안 개선 대상이었던 레거시 시스템의 세션 의존성 제거 작업에 대해서 적어보도록 하겠습니다.

## 이전 글
- [1.대량 상품 출고 데이터 처리](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/1.%EB%8C%80%EB%9F%89%20%EC%83%81%ED%92%88%20%EC%B6%9C%EA%B3%A0%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%B2%98%EB%A6%AC.md)
- [2.서비스간 의존성 격리: 트랜잭셔널 아웃박스 패턴](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2.%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B0%84%20%EC%9D%98%EC%A1%B4%EC%84%B1%20%EA%B2%A9%EB%A6%AC%3A%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90%20%EC%95%84%EC%9B%83%EB%B0%95%EC%8A%A4%20%ED%8C%A8%ED%84%B4.md)
- [3.주문 개선하기: 시퀀스 테이블 페이드아웃](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/3.%EC%A3%BC%EB%AC%B8%20%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0%3A%20%EC%8B%9C%ED%80%80%EC%8A%A4%20%ED%85%8C%EC%9D%B4%EB%B8%94%20%ED%8E%98%EC%9D%B4%EB%93%9C%EC%95%84%EC%9B%83.md)
- [4.재고 개선하기: 재고 업데이트 안정화](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/4.%EC%A3%BC%EB%AC%B8%20%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0%3A%20%EC%9E%AC%EA%B3%A0%20%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%20%EC%95%88%EC%A0%95%ED%99%94.md)
- [5.신규 장바구니 페이지 안전하게 오픈하기](https://github.com/ejoongseok/blog/blob/main/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/5.%20%EC%8B%A0%EA%B7%9C%20%EC%9E%A5%EB%B0%94%EA%B5%AC%EB%8B%88%20%ED%8E%98%EC%9D%B4%EC%A7%80%20%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C%20%EC%98%A4%ED%94%88%ED%95%98%EA%B8%B0.md)


## 문제 상황
케타포 커머스 시스템에서는 오래전부터 세션 ID가 중복 생성되는 문제가 발생하고 있었다. 
짐작하기로는, 이 문제는 2017년 이전부터 발생하고 있었다. 

이런 이유로 레거시 코드 내에서는 세션 ID의 고유성을 보장하기 위해 `prefix`와 `postfix`를 추가하는 방식을 사용하고 있었으나,   
이는 임시방편일 뿐 근본적인 문제 해결과는 거리가 있었다. 

톰캣 기반 웹 애플리케이션 개발을 하면서 경력 동안 세션이 중복되는 경우는 처음 겪는 일이었고, 열심히 찾아보았지만 정확한 원인은 알 수 없었다.  
특징으로는 인스턴스의 개수가 증가할수록 세션 중복 발생 빈도가 높아졌다.   
예를 들어, 인스턴스가 2개일 때는 한 달에 한두 번 발생하던 문제가, 16개로 늘어나면 하루에 100건 이상 발생하는 상황까지 이르렀다.   

참고로, 세션은 Redis를 통해 관리되고 있었다.   
세션 ID 중복의 원인을 명확히 파악할 수 있었다면 좋았겠지만, 그렇지 않더라도 이 문제를 해결하기 위한 방향을 찾는 것이 시급했다. 

임시방편으로 추가된 `prefix`와 `postfix` 덕분에 당장 치명적인 문제는 없었으나,   
올바른 구조가 아니었기 때문에 세션에 의존하지 않도록 레거시 코드를 개선해야한다는 결론에 이르렀다.

## 세션 의존성의 복잡성
기존 세션에는 다양한 정보가 포함되어 있었다. 사용자 이력, 보안 관련 데이터, 심지어는 과거에는 JSP에 렌더링할 HTML Footer까지 세션에 저장될 정도로 세션은 마치 도라에몽 주머니와 같은 역할을 하고 있었다.

이 레거시 코드의 핵심에는 SessionManager라는 클래스가 있었다. 이 클래스는 시스템 전역에서 광범위하게 사용되고 있었으며,   
핵심 비즈니스 로직과 다양한 유틸리티 기능을 모두 담고 있었다. SessionManager는 일종의 갓 클래스(God Class)였던 셈이다.  

SessionManager는 Map을 반환하거나 Object를 반환하는 메서드가 많았었는데, 해당 메서드를 사용하는 곳에서 캐스팅해서 사용하는 이해하기 어렵고 까다로운 로직들이 많이 있었다.   

## 제거 방법

1. **코드 분석 및 불필요한 기능 제거**  
우선 Big Ball of Mud인 SessionManager에 의존하는 코드들을 리스트업 한 뒤 변경하기 쉽게 만들어야 했다.  
그래서 리스트업 한 기능 중 사용되지 않는 기능들을 제거했다.

3. **코드 중복 제거**  
코드 중복을 줄이기 위해 인텔리제이를 이용해 `introduce variable` 으로 중복 호출되던 값들을 변수로 추출해 API 내에서 중복을 제거한 뒤 `extract method`를 통해 각 기능별로 변수로 추출된 중복 로직을 정리했다.(레거시는 컨트롤러 하나에 3천줄이 넘어간다.)  
그 다음 SessionManager에서 반환하는 Map, Object 타입을 캐스팅해서 사용하는 로직들을 좀 더 명시적인 값으로 반환하도록 전부 `move instance method`로 SessionManager 안으로 응집시켰다.  

4. **역할과 책임의 분리**  
SessionManager의 메서드 시그니처(Signature)와 반환 타입을 분석하여, 각 기능이 사용되는 곳들을 보면서 역할과 책임을 구분해서 정리했다.  
이를 통해 역할과 책임을 나눌 클래스들을 만들고, SessionManager에서 반환하던 기존의 분산된 로직을 해당 클래스로 이동시켜 SessionManager에는 해당 클래스의 인스턴스를 생성해서 반환하는 로직만 남기도록 했다.  
여기까지 작업하니 SessionManager에서 반환하는 public 메서드를 많이 줄일 수 있었다.  

5. **인터페이스 추출**  
SessionManager의 public method를 `extract interface` 해서 SessionManager가 해당 인터페이스의 구현체가 되도록 변경했다.    
이후, SessionManager를 의존하던 기능들을 새로 만든 인터페이스에 의존하도록 변경 하면서 SessionManager의 의존성을 점진적으로 줄여 나갔다.    

6. **대체 클래스 도입 및 피처 플래그 적용**  
각 인터페이스의 구현체에 세션을 대체할 새로운 클래스들을 설계하고, Feature Flag를 도입하여 새로 만든 클래스에서 장애가 발생하면 언제든 SessionManager로 롤백할 수 있도록 작업했다.  
또한, 혹시 모를 문제에 대비해 플래그가 켜지더라도 세션의 값과 새로 대체할 클래스가 반환한 값을 비교해서 다르면, 세션의 값을 반환하고 로그를 남기도록 처리했다.    
이후 새로운 클래스를 단계적으로 활성화하면서 천천히 하나씩 세션 의존성을 제거해나갔다.  
SessionManager를 페이드아웃 하면서는 세션에서 조회하는 기능들만 페이드아웃 했다. 왜냐하면 조회를 전부 변환하면, 세션에 설정하던 기능들은 더 이상 필요가 없으니 자연스레 제거할 수 있기 때문이었다.

8. **카나리 릴리스 전략 적용**  
세션이 시스템 전역에 영향을 미치기 때문에, 신규 장바구니를 오픈할 때 사용했던 카나리 방식을 응용해서 우선 특정 상점에서 아주 낮은 비율만 새로운 구현체를 사용하도록 활성화해서 혹시 모를 버그에 대비하며 안전하게 제거해 나갔다.    
이를 통해 장애 없이 안정적으로 세션을 전환할 수 있었다.

9. **세션 제거 필터 적용**  
이제 명시적으로 세션이 사용되는곳은 모두 제거 했지만 아직 내가 찾지 못한곳에서 세션이 여전히 사용되고 있을 수 있었기 때문에 세션을 직접 제거하는 로직을 추가해서 세션이 정말 사용되지 않는지를 검증해야했다.  
레거시 시스템은 `spring framework 3.2` 버전, `servlet3.1`인 오래된 버전을 사용하고 있었는데 내가 찾아봤을때는 web.xml 설정 같은걸로 간단하게 세션을 비활성화 할 수가 없었다.  
그래서 Servlet Filter를 추가해 요청이 들어오면 세션을 제거하는 로직을 추가했다. 이 작업 역시 상점을 하나씩 오픈하면서 혹시 모를 버그를 최소화 했다.

10. **레디스 세션 플러그인 제거**  
세션 제거 필터를 적용한 뒤에도 시간을 두고 문제가 발생하는지 모니터링을 한 뒤 문제가 없다고 판단하여 팀의 데브옵스 분께 부탁해서 레디스 세션 플러그인을 제거했다.  
이로써 레거시 시스템은 세션 관리에서 해방될 수 있게 되었다.

관련 내용: [레거시 시스템을 개선하며 배운 안정적 전환 기술](https://github.com/ejoongseok/blog/blob/main/%EA%B8%B0%EC%88%A0/%EB%A0%88%EA%B1%B0%EC%8B%9C%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84%20%EA%B0%9C%EC%84%A0%ED%95%98%EB%A9%B0%20%EB%B0%B0%EC%9A%B4%20%EC%95%88%EC%A0%95%EC%A0%81%20%EC%A0%84%ED%99%98%20%EA%B8%B0%EC%88%A0.md)

## 마무리 및 회고
전체 과정은 2달여간 천천히, 단계별로 진행되었다.   
이번 작업을 통해 로그를 정말 자주 모니터링하는 습관을 기르게 되었다.   
그리고 상용 배포 전에 스테이징 서버를 적극적으로 활용하면서 버그를 사전에 방지할 수 있었다.

작업하면서 어려웠던 부분은 역시 로그인과 개인화 정보 그리고 JSP에서 사용되는 세션 정보들이었다.   
이렇게 안전하게 작업할 수 있도록 계획을 세워주고 어려움이 있을 때마다 도움을 주신 팀장님 덕분에 레거시 프로젝트에서 큰 규모의 시스템 개선을 해볼 수 있는 값진 경험을 얻을 수 있었다.
