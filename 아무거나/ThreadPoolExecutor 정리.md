# ThreadPoolExecutor 정리

## 엔터프라이즈 웹 애플리케이션에서 자주 사용하는 ThreadPoolExecutor

### newFixedThreadPool
- 설정된 수량만큼의 스레드를 생성하여 작업을 처리한다.
- 작업 큐로는 `LinkedBlockingQueue`를 사용하는데, 기본적으로 크기가 무한이므로, 작업이 빠르게 쌓여 메모리 문제를 일으킬 수 있다.  
따라서 엔터프라이즈 환경에서는 큐의 크기를 제한하는 것이 좋다.
- 고정된 스레드 수를 넘어서는 작업이 많아지면, 작업이 큐에서 대기하는 시간이 길어질 수 있다.

### newSingleThreadExecutor
- 단일 스레드만을 사용하여 작업을 처리하므로, 다중 스레드 환경에서 발생할 수 있는 동시성 문제를 피할 수 있다.
- 단일 스레드가 모든 작업을 처리하기 때문에, 작업 중 하나가 오래 걸리면 이후 작업이 지연될 수 있다.
- 주로 중요한 로그 기록이나 순차적으로 처리해야 하는 간단한 작업에 적합하다.

## CPU 집약적인 서비스에서 사용하는 경우

### newWorkStealingPool
- Java 8부터 도입된 스레드 풀로, `ForkJoinPool`을 사용하여 작업을 병렬로 효율적으로 분배한다.
- 대규모 작업을 작은 단위로 쪼개어 병렬로 실행할 때 효과적이며, CPU 집약적인 작업에 적합하다.
- 가용한 CPU 코어 수에 따라 스레드 수가 결정된다. (예: CPU가 8개이면 기본적으로 8개의 스레드가 생성된다.)
- CPU보다 I/O 사용이 빈번한 웹 서비스에서는 사용 하지 않을 수 있다.

## 엔터프라이즈 환경에서 사용하기에 위험한 ThreadExecutor

### newCachedThreadPool
- 필요에 따라 동적으로 스레드를 생성할 수 있는 스레드 풀.
- 스레드 수가 제한되지 않기 때문에, 서버 자원을 초과할 위험이 있다.  
따라서, 작은 규모의 일회성 작업이 많은 경우에만 사용을 고려하는 것이 좋다. (예: 테스트)

---

# 상세 내용

### newFixedThreadPool
- 설정된 수량만큼의 스레드를 생성하고, 그 풀 내에서 작업을 처리한다.
- 일반적으로 I/O 작업이 많거나 동시에 처리해야 할 작업의 수가 많을 때 사용된다. 예를 들어 스레드 풀 사이즈를 CPU보다 많은 200으로 설정해서 사용.
- `ThreadPoolExecutor`의 `corePoolSize`와 `maximumPoolSize`를 동일하게 설정하여 스레드 수가 고정된 스레드 풀을 만든다.
- 작업 큐로는 `LinkedBlockingQueue`를 사용하며, 대기 중인 작업이 큐에 저장된다. 기본적으로 큐의 크기가 무한이므로 크기를 제한하는 것이 좋다.

### newSingleThreadExecutor
- 하나의 스레드만을 사용하는 스레드 풀을 생성헌다.
- 주로 순차적으로 작업을 처리해야 하는 경우에 사용되며, 스레드 안전성이 중요한 작업(예: 로깅)에 적합하다.
- 모든 작업이 순차적으로 실행되며, 이전 작업이 완료되어야 다음 작업이 실행된다.
- 내부적으로는 `corePoolSize`와 `maximumPoolSize`가 1로 설정된 `ThreadPoolExecutor`를 사용하며, 작업 큐로 `LinkedBlockingQueue`를 사용해 모든 작업을 순차적으로 실행한다.

### newWorkStealingPool
- Java 8부터 도입된 스레드 풀로, 가용한 CPU 코어 수를 활용하여 병렬로 작업을 처리한다.
- CPU 집약적인 작업에서 효율적이며, 작업을 여러 개의 작은 단위로 나누어 처리할 수 있는 경우에 적합하다.
- 이 풀은 `ForkJoinPool`을 기반으로 하며, 가용한 CPU 코어 수에 따라 스레드 수가 결정된다.

### newCachedThreadPool
- 필요에 따라 동적으로 스레드를 생성할 수 있는 스레드 풀이다.
- 매우 많은 단기 작업이 있을 때 유용하지만, 스레드 수가 예측할 수 없이 증가할 수 있어 시스템에 과부하를 줄 수 있으므로 신중히 사용해야한다.
- 일반적으로 서비스 안정성이 중요한 엔터프라이즈 환경에서는 잘 사용되지 않는다.
- `corePoolSize`가 0으로 설정되어 있어, 작업이 들어올 때마다 새로운 스레드를 생성한다. `SynchronousQueue`를 사용하기 때문에, 작업이 들어오면 큐에 저장되지 않고 즉시 처리할 수 있는 스레드가 없을 경우 새로운 스레드가 생성된다. 이로 인해 스레드가 재활용되지 않고 계속해서 새로운 스레드를 생성하게 되므로, 서버 자원을 초과할 위험이 있다.
